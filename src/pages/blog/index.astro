---
import Layout from '../../layouts/Layout.astro';
import Nav from '../../components/Nav.astro';

// Fetch all markdown files in the blog directory
const allPosts = await Astro.glob('./*.md');

// Sort by date or just reverse so newest is on top (since there is no date now, just raw array)
const sortedPosts = allPosts;
---

<Layout title="Blog | Alberto Maccanico">
  <Nav />
  
  <!-- Cool technical neural network background animation -->
  <canvas id="blog-bg-canvas" class="fixed inset-0 w-full h-full pointer-events-none z-[-1] opacity-40"></canvas>
  
  <div class="max-w-5xl mx-auto py-32 px-6 min-h-screen relative z-10">
    <div class="mb-16 section-fade">
      <h1 class="text-4xl md:text-5xl font-bold mb-4">
        <span class="gradient-text">Blog & Articles</span>
      </h1>
      <div class="w-16 h-1 bg-gradient-to-r from-accent-blue to-accent-purple rounded-full mt-8"></div>
    </div>

    <div class="grid md:grid-cols-2 gap-6">
      {sortedPosts.map((post) => {
        const { title, description, publication } = post.frontmatter;
        return (
          <a
            href={post.url}
            class="glass rounded-2xl p-6 section-fade glow-border group block hover:scale-[1.02] transition-transform cursor-pointer"
          >
            <div class="flex items-start justify-between mb-4">
              <div class="w-10 h-10 rounded-xl bg-gradient-to-br from-accent-blue/20 to-accent-purple/20 flex items-center justify-center group-hover:from-accent-blue/30 group-hover:to-accent-purple/30 transition-colors">
                <svg class="w-5 h-5 text-accent-purple" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" />
                </svg>
              </div>
              <svg class="w-4 h-4 text-text-muted group-hover:text-accent-blue transition-colors" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25" />
              </svg>
            </div>
            <h2 class="font-semibold text-text-primary text-xl mb-2 group-hover:text-accent-blue transition-colors">{title}</h2>
            <p class="text-text-secondary text-sm leading-relaxed">{description}</p>
            {publication && <p class="text-text-muted text-xs font-mono mt-3">{publication}</p>}
          </a>
        );
      })}
    </div>
  </div>
</Layout>

<script>
  import { gsap } from "gsap";

  // Timeline for a gorgeous staggered entrance on load
  const tl = gsap.timeline();

  const header = document.querySelector('.max-w-5xl > .mb-16');
  const cards = document.querySelectorAll('.grid > a.glass');

  if (header) {
    tl.fromTo(header,
      { y: 30, opacity: 0 },
      { y: 0, opacity: 1, duration: 0.8, ease: "power3.out" }
    );
  }

  if (cards.length > 0) {
    tl.fromTo(cards,
      { y: 50, opacity: 0, scale: 0.95 },
      { y: 0, opacity: 1, scale: 1, duration: 0.8, stagger: 0.15, ease: "back.out(1.2)" },
      "-=0.4" // Start animating cards slightly before header finishes
    );
  }

  // 3D MOUSE-FOLLOWING CARD TILT
  cards.forEach((card) => {
    const cardEl = card as HTMLElement;
    
    cardEl.addEventListener('mousemove', (e) => {
      const rect = cardEl.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      const centerX = rect.width / 2;
      const centerY = rect.height / 2;
      
      const rotateX = ((y - centerY) / centerY) * 8; 
      const rotateY = ((x - centerX) / centerX) * -8;
      
      cardEl.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(1.02)`;
      
      // Update glow gradient position
      cardEl.style.setProperty('--mouse-x', `${(x / rect.width) * 100}%`);
      cardEl.style.setProperty('--mouse-y', `${(y / rect.height) * 100}%`);
    });
    
    cardEl.addEventListener('mouseleave', () => {
      cardEl.style.transform = 'perspective(1000px) rotateX(0deg) rotateY(0deg) scale(1)';
      cardEl.style.transition = 'transform 0.5s ease';
      setTimeout(() => {
        cardEl.style.transition = 'transform 0.1s ease-out';
      }, 500);
    });
  });

  // ==========================================
  // TECHNICAL BACKGROUND ANIMATION (Neural Network)
  // ==========================================
  const canvas = document.getElementById('blog-bg-canvas') as HTMLCanvasElement;
  if (canvas) {
    const ctx = canvas.getContext('2d');
    if (ctx) {
      let width = canvas.width = window.innerWidth;
      let height = canvas.height = window.innerHeight;

      window.addEventListener('resize', () => {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
      });

      const particles: {x: number, y: number, vx: number, vy: number, size: number}[] = [];
      const particleCount = Math.floor((window.innerWidth * window.innerHeight) / 15000); // responsive count
      const connectionDistance = 150;

      for (let i = 0; i < particleCount; i++) {
         particles.push({
           x: Math.random() * width,
           y: Math.random() * height,
           vx: (Math.random() - 0.5) * 0.6,
           vy: (Math.random() - 0.5) * 0.6,
           size: Math.random() * 2 + 0.5
         });
      }

      let mouse = { x: -1000, y: -1000 };
      document.addEventListener('mousemove', (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });

      function render() {
        if (!ctx) return;
        ctx.clearRect(0, 0, width, height);

        for (let i = 0; i < particles.length; i++) {
          let p = particles[i];
          
          p.x += p.vx;
          p.y += p.vy;

          if (p.x < 0 || p.x > width) p.vx *= -1;
          if (p.y < 0 || p.y > height) p.vy *= -1;

          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(0, 212, 255, 0.6)';
          ctx.fill();

          // Connect particles to each other
          for (let j = i + 1; j < particles.length; j++) {
            let p2 = particles[j];
            let dx = p.x - p2.x;
            let dy = p.y - p2.y;
            let dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < connectionDistance) {
              ctx.beginPath();
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(p2.x, p2.y);
              let opacity = 1 - (dist / connectionDistance);
              // using accent-purple for connections between nodes
              ctx.strokeStyle = `rgba(124, 58, 237, ${opacity * 0.25})`;
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
          
          // Connect to mouse and attract
          let dxMouse = p.x - mouse.x;
          let dyMouse = p.y - mouse.y;
          let distMouse = Math.sqrt(dxMouse * dxMouse + dyMouse * dyMouse);
          if (distMouse < 200) {
             ctx.beginPath();
             ctx.moveTo(p.x, p.y);
             ctx.lineTo(mouse.x, mouse.y);
             let opacity = 1 - (distMouse / 200);
             // using accent-blue for mouse connections
             ctx.strokeStyle = `rgba(0, 212, 255, ${opacity * 0.4})`;
             ctx.stroke();
             
             // Slight attraction to mouse
             p.vx -= (dxMouse / distMouse) * 0.015;
             p.vy -= (dyMouse / distMouse) * 0.015;
          }
          
          // Speed limit
          let speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
          if (speed > 1.2) {
            p.vx = (p.vx / speed) * 1.2;
            p.vy = (p.vy / speed) * 1.2;
          }
        }

        requestAnimationFrame(render);
      }
      render();
    }
  }
</script>
